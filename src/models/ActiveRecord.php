<?php
/**
 * Copyright (c) 2019.
 *
 * @author Igor A Tarasov <develop@dicr.org>
 */

declare(strict_types = 1);
namespace dicr\admin\models;

use dicr\admin\behaviors\UpsertBehavior;
use dicr\cache\CacheBehavior;
use function call_user_func;

/**
 * Базовая модель.
 *
 * @method void invalidateModelCache() учищает элементы кэша с зависимостью от класса данной модели
 * @method void upsert($runValidation = true, $attributes = null) сохраняет методом upsert (без получения autogenerated
 *     ключей !!!)
 *
 * @author Igor (Dicr) Tarasov <develop@dicr.org>
 * @version 2019
 */
abstract class ActiveRecord extends \yii\db\ActiveRecord
{
    /**
     * {@inheritDoc}
     * @see \yii\base\Component::behaviors()
     */
    public function behaviors()
    {
        return array_merge(parent::behaviors(), [
            'cache' => CacheBehavior::class,
            'upsert' => UpsertBehavior::class
        ]);
    }

    /**
     * Статический метод для очистки кэша.
     *
     * Использует invalidateModelCache
     */
    public static function invalidateClassCache()
    {
        $class = static::class;

        /** @var static $instance */
        $instance = call_user_func([$class, 'instance']);
        $instance->invalidateModelCache();
    }

    /**
     * {@inheritDoc}
     * @see \yii\db\ActiveRecord::updateAll($attributes, $condition, $params)
     */
    public static function updateAll($attributes, $condition = '', $params = [])
    {
        parent::updateAll($attributes, $condition, $params);
        static::invalidateClassCache();
    }

    /**
     * {@inheritdoc}
     * @see \yii\db\ActiveRecord::updateAllCounters($counters, $condition, $params)
     */
    public static function updateAllCounters($counters, $condition = '', $params = [])
    {
        parent::updateAllCounters($counters, $condition, $params);
        static::invalidateClassCache();
    }

    /**
     * {@inheritdoc}
     * @see \yii\db\ActiveRecord::deleteAll($condition, $params)
     */
    public static function deleteAll($condition = null, $params = [])
    {
        parent::deleteAll($condition, $params);
        static::invalidateClassCache();
    }

    /**
     * Создает и загружает массив моделей из табулярных данных.
     *
     * Чтобы каждый раз при сохранении не удалять/пересоздавать все табулярные модели заново,
     * можно использовать уже существующие в базе, для обновления при помощи save().
     *
     * В $current передается массив существующих в базе моделей для загрузки. Этот массив должен быть индексирован по
     * такому же ключу как и данные формы.
     *
     * В $data[$formName] передается массив данных отправленных моделей, индексированный по ключу-идентификатору
     * модели. Если модель с таким ключем отсутствует в массиве существующих ($models), то создается новая.
     *
     * Если $current не задан, то все модели будут созданы из данных.
     *
     * Модели из $current, ключ которых отсутствует в данных формы не возвращаются.
     *
     * @param array $currentModels
     * @param array $data табулярные данные, например из $_POST
     * @param string $formName
     * @return static[]
     * @throws \yii\base\InvalidConfigException
     */
    public static function loadAll(array $currentModels, array $data, string $formName = null)
    {
        if (empty($currentModels)) {
            $currentModels = [];
        }

        if (! isset($formName)) {
            $formName = static::instance()->formName();
        }

        // коррекируем данные под форму
        if ($formName !== '') {
            $data = $data[$formName] ?? [];
        }

        $models = [];
        foreach ($data as $key => $modelData) {
            $model = $currentModels[$key] ?? new static();
            $model->load($modelData, '');
            $models[$key] = $model;
        }

        return $models;
    }
}
